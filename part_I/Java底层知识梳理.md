---
layout: default

---

# Java底层知识梳理：

这里主要是整理一下不太常见的关于Java的知识点：

## 类的加载顺序

有父子关系的类在加载时，先调用父类静态初始化块，静态属性，但不包括静态方法，然后再是，子类静态初始化块，静态属性，但同样不包括静态方法 。



## 类加载的过程：

**加载->连接->初始化**

加载过程：

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口

连接步骤可分为：验证->准备->解析



## 有哪些类加载器？

1. **BootstrapClassLoader(**启动类加载器**)** :最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib 目录下的jar包和类或者或被 -Xbootclasspath 参数指定的路径中的所有类。
2. **ExtensionClassLoader(**扩展类加载器**)** :主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。
3. **AppClassLoader(**应用程序类加载器**)** :面向我们用户的加载器，负责加载当前应用classpath下所有jar包和类。



## 什么是双亲委派模型？

每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 双亲委派 模型 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则 才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 **loadClass()** 处理，因此所有的请 求最终都应该传送到顶层的启动类加载器 **BootstrapClassLoader** 中。当父类加载器无法处理时，才由 自己来处理。当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。

![image-20210706210134633](../resource/img/双亲委派模型.png)

[back](../)

