---
layout: default

---

# 线程和进程深度解析

## 进程(Process)和线程(Thread)的区别：

- **根本区别**：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。一个进程可以包含一个或多个线程。
- **资源开销**：每个进程都有独立的代码和数据空间（程序上下文），进程切换的开销大；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程切换的开销小。
- **影响关系**：一个进程崩溃后，在保护模式下不会对其他进程产生影响。但是一个线程崩溃后，会导致整个进程崩溃。所以多进程要比多线程健壮。

### 进程间通信的方式：

- **共享内存（shared memory）**

  可以使多个进程访问同一内存空间，不同的进程可以看到对方进程对共享内存当中的数据作出的更新。因此，还需要依赖同步操作，例如互斥锁和信号量。

- **套接字SOCKET**

  socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。

- **管道**

  - **匿名管道（PIPE）**：数据只能在一个方向上流通，只能用于具有亲缘关系的进程之间的通信。不属于任何文件系统，而存在于内存之中。
  - **有名管道（FIFO）**：可以在无关的进程之间交换数据。它以一种特殊设备文件形式存在于文件系统中。

- **系统IPC**
  - **消息队列**：是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 
  - **信号量**：用来控制多个进程对共享资源的访问的计数器，用于共享内存中

### 线程间通信的方式：

- **临界区**：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问
- **互斥量Synchronized/Lock**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 
- **信号量Semphare**：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
- **事件(信号)，Wait/Notify**：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作进程间通信的方式：

### 线程的五种状态：

- **New**：初始状态，线程被构建，但是还未调用start()方法

- **Runnable**：就绪状态

  导致线程进入就绪状态的原因：

  1. 新建线程：调用start（）方法，进入就绪状态
  2. 阻塞线程：阻塞接触，进入就绪状态
  3. 运行线程：调用yield（）方法，直接进入就绪状态
  4. 运行线程：JVM将CPU资源从本线程切换至其他线程

- **Running**：运行状态

- **Blocked**：阻塞状态，表示线程被锁阻塞

  导致线程进入阻塞状态的原因：

  1. 执行sleep（）方法，使当前线程休眠，进入阻塞状态
  2. 执行wait（）方法，是当前线程进入阻塞状态
  3. 线程运行时，某个操作进入阻塞状态，比如执行IO流操作
  4. join（）线程联合：当某个线程等待另一个线程执行结束后，才能继续执行时，使用join（）方法

- **Terminate**：终止状态，表示当前线程已经执行完毕

  造成线程死亡的原因：

  1. 正常运行的线程完成了run（）方法内的全部工作
  2. 线程被强制终止，如通过执行stop（）或者destroy（）方法来终止线程。

### 进程的五种状态：

- **New**：创建状态
- **Ready**：就绪状态，程序已经准备运行，获得了除了处理器之外的一切所需资源，一旦得到处理器资源即可运行
- **Running**：运行状态
- **Waiting**：阻塞状态，又称为等待状态，进程正在等待某一事件而暂停运行，如等待某资源为可用或等待IO操作完成
- **结束状态**：进程正在从系统中消失

[back](../)

