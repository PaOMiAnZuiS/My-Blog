---
layout: default


---

# 字符串匹配的KMP算法

Knuth-Morris-Pratt算法常用于字符串匹配，是一个非常经典的算法，以下尝试用笔者的语言进行梳理。

我们有字符串**string**和目标字符串**target**，目的是找到**string**当中是否包含**target**，如果是，则返回**target**所在的位置。

1. 遍历匹配**string**当前位置的字符串和**target**的第一个字符是否相等

2. 若搜索到**string**当前位置的字符串和**target**第一个字符相等，则遍历比较**string**接下来的字符串是否和**target**接下来的字符串相等

3. 如果**string**和**target**接下来的字符串并不完全相等，则根据这两个字符串，制作**部分匹配表**（Partial Match Table）

   ### 部分匹配表：

   部分匹配表就是字符串前缀和后缀的共有长度，以**abcba**为例：

   | 搜索词：         | a b c b a |
   | ---------------- | --------- |
   | **部分匹配值：** | 0 0 0 0 1 |

   - a的前缀和后缀都为空集，共有元素长度为0，因此a对应0
   - ab的前缀为[a]，后缀为[b]，共有元素长度为0，因此b对应0
   - abc的前缀为[a,ab]，后缀为[bc,c]，共有元素长度为0，因此c对应0
   - abcb的前缀为[a,ab,abc]，后缀为[bcb,cb,b]，共有元素长度为0,因此b对应0
   - abcba的前缀为[a,ab,abc,abcb]，后缀为[bcba,cba,ba,a]，共有元素为a，长度为1，因此a对应1

   **部分匹配的实质是，有时候，字符串的头部和尾部都会重复。**

4. 根据**string**和**target**当前匹配位置的部分匹配值，进行位移（位移长度为**target**的长度-当前位置的部分匹配值）。

5. 直到搜索到目标位置，或者遍历完**string**。

[back](../)
