---
layout: default


---

# 常见的设计模式：

## 软件设计的七大原则：

| 设计原则     | 内容                                                         | 目的                     |
| ------------ | ------------------------------------------------------------ | ------------------------ |
| 开闭原则     | 对扩展开放，对修改关闭                                       | 降低维护带来的风险       |
| 依赖倒置原则 | 高层不应该依赖低层，要面向接口编程                           | 更利于代码结构的升级扩展 |
| 单一职责原则 | 一个类只干一件事，实现类要单一                               | 便于理解，提高代码可读性 |
| 接口隔离原则 | 一个接口只干一件事，接口要精简单一                           | 功能解耦，高聚合，低耦合 |
| 迪米特法则   | 不该知道的不要知道，一个类应该保持对其他对象最少的了解，降低耦合度 | 减少代码臃肿             |
| 里氏替换原则 | 不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义 | 防止继承泛滥             |
| 合成复用原则 | 尽量使用组合或者聚合关系实现代码复用，少使用继承             | 降低代码耦合             |



1. ## 简单工厂模式

   **简单工厂模式**又叫**静态工厂方法模式**，因为在简单工厂模式中创建实例的方法通常是静态方法。定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。

   简单工厂模式的**优点**：

   - 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品类的实例
   - 客户端无需知道所创建的产品的类名，只需知道参数即可
   - 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类

   简单工厂模式的**缺点**：

   - 简单工厂模式的工厂类单一，负责所有产品的创建，一旦异常，整个系统受损
   - 使用简单工厂模式会增加系统中类的个数，增加系统的复杂度和理解难度
   - 系统扩展困难，一旦增加新产品就得修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂
   - 简单工厂模式使用了static工厂方法，造成工厂角色无法形成基于继承的等级结构

2. ## 工厂方法模式

   **工厂方法模式**是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。

   工厂方法模式的**优点**：

   - 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。
   - 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。
   - 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。

   工厂方法模式的**缺点**：

   - 类的个数容易过多，增加复杂度
   - 增加了系统的抽象性和理解难度
   - 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。

3. ## 抽象工厂模式

   抽象工厂模式是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。

   抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。

   抽象工厂模式的**优点**：

   - 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
   - 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。
   - 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。

   抽象工厂模式的**缺点**：

   - 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。

4. ## 单例模式

   单例模式指一个类只能有一个实例，并且该类能够自行创建这个实例。

   单例模式的**特点**：

   - 单例类只有一个实例对象
   - 该单例对象必须由单例类自行创建
   - 单例类对外提供一个访问该单例的全局访问点

   单例模式的**优点**：

   - 单例模式保证内存里只有一个实例，减少了内存开销
   - 可以避免对资源的多重占用
   - 单例模式设置全局访问点，可以优化和共享资源的访问

   单例模式的**缺点**：

   - 单例模式一般没有接口，扩展困难
   - 在并发测试中，单例模式不利于代码调试
   - 单例模式的功能代码通常写在一个类中，如果功能设计不合理，很容易违背单一职责的原则

5. ## 代理模式

   代理模式的定义是由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介

   代理模式的**优点**：

   - 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用
   - 代理对象可以扩展目标对象的功能
   - 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性

   代理模式的**缺点**；

   - 代理模式会造成系统设计中类的数量增加
   - 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢
   - 增加了系统的复杂度

6. ## 原型模式

   原型模式用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。

   原型模式的**优点**：

   - Java自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。
   - 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。

   原型模式的**缺点**：

   - 需要为每一个类都配置一个 clone 方法
   - clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
   - 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。

[back](../)

