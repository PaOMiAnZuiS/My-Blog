---
layout: default


---

# Java GC

## 判断对象是垃圾的两种方法？

- **引用计数法：**

  在对象中添加一个引用计数器，如果对象被引用，计数器+1，如果引用失效，计数器-1。计数器为0的对象就是垃圾。

  缺点：如果对象之间循环引用，此法失效。



- **可达性分析：**

  通过GC Roots作为起点，通过起点向下遍历，未被遍历到的对象就是垃圾。

  GC Roots的范围：

  - 虚拟机栈中的对象
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中JNI引用的对象



## 常用的GC方法：

- **mark-sweep 标记-清除法：**

  遍历所有对象，标记出垃圾对象，然后直接清空。

  简单有效，但会产生很多内存碎片（空闲内存不连续）。

- **mark-copy 标记-复制法：**

  将内存对半分，遍历所有对象，标记出非垃圾对象，将非垃圾对象复制到内存的另一边。

  避免了内存碎片的问题，但是内存浪费很严重。

- **mark-compact 标记-整理法：**

  遍历所有对象，标记出垃圾对象，清空后，将剩下的对象进行整理，避免了上面两种方法的缺点，但同时额外产生了整理的开销。

- **generation-collect 分代收集算法:**

  ![image-20210709145547693](../resource/img/JVM内存分代.png)

  在Hotspot中，内存被分为三大块， **年青代**(Young Generation)，**老年代**(Old Generation)和永久代(Permanent Generation)，年青代又可分为**eden**，**s0**和**s1**三个区。

  对象刚被创建时，被分配在**eden**区，当**eden**区放不下的时候，就发生一次**minor GC**（或者叫young GC），具体为：**标记-清除 eden**， 然后**标记-复制 eden->s0**，经过**minor GC**之后，**eden**就空了，存活下来的对象都进入了**s0**。若下一次**eden**又满了，再进行一次**minor GC**，经过这一次**minor GC****之后存活的在**eden**和**s0**中的对象全部都搬到**s1**。

  对于那些经常在**s0**和**s1**之间搬来搬去的长寿对象，一旦他们的年龄（每搬一次，年龄+1）达到阈值（默认15）， 则会被移到**老年代**当中。

  如果**老年代**也放满了，则会发生**Full GC**（又叫major GC），由于**老年代**的的对象通常会比较多，因为**标记-清理-整理（压缩）**的耗时通常会比较长，会让应用出现卡顿的现象，这也是为什么很多应用要优化，尽量避免或减少 **Full GC** 的原因。



## 垃圾收集器：



[back](../)
