---
layout: default

---

# 浮点数的精度丢失：

#### 精度丢失的原因：

1. 计算机是二进制实现，十进制数的二进制表示形式可能不准确
2. 位数限制（双精度浮点数64位(double)，单精度浮点数32位(float)）
3. 使用的数字之间类型不匹配（混合使用浮点型和双精度型）

例（double的实现）：

| s           | eeeeeee eeee | ffff ffffffff ffffffff ffffffff ffffffff ffffffff |
| ----------- | ------------ | ------------------------------------------------- |
| 1（符号位） | 11（指数）   | 52（尾数）                                        |

接下来看具体实现：

 (1) 十进制整数如何转化为二进制数

​      算法很简单。举个例子，11表示成二进制数：

​           11/2=5 余  1

​            5/2=2  余  1

​            2/2=1  余  0

​            1/2=0  余  1

​             0结束     

​			11二进制表示为(从下往上):1011

​     这里提一点：只要遇到除以后的结果为0了就结束了，大家想一想，所有的整数除以2是不是一定能够最终得到0。换句话说，所有的整数转变为二进制数的算法会不会无限循环下去呢？绝对不会，***\*整数永远可以用二进制精确表示\**** ，但小数就不一定了。



 (2) 十进制小数如何转化为二进制数

​      算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数

​           0.9*2=1.8  取整数部分 1

​           0.8(1.8的小数部分)*2=1.6  取整数部分 1

​           0.6*2=1.2  取整数部分 1

​           0.2*2=0.4  取整数部分 0

​           0.4*2=0.8  取整数部分 0

​           0.8*2=1.6 取整数部分 1

​           0.6*2=1.2  取整数部分 0

​               .........   0.9二进制表示为(从上往下): 1100100100100......

​      注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，**\*小数的二进制表示有时是不可能精确的\*** 。其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了"减不尽"的精度丢失问题。

[back](../)

